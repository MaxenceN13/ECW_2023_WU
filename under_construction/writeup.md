# PROBLEME
Un script app.py qui est exécuté sur un serveur distant.

# SOLUTION
On remarque que le script utilise le framework flask et une librairie validate_email.
Après analyse du script, on remarque l'utilisation d'un render_template_string qui utilise un input utilisateur, qui correspond à une SSTI (Server-Side Template Injection). On souhaiterait donc injecter du code exécuté par flask à l'aide de {{}} ou {%%}. Malheusement, on doit pouvoir passer le validateur d'email. Après rechercher, on trouve la possiblité d'utiliser des "quoted email address" qui permet l'utilisation des caractères !#$%&'*+-/=?^_`{|}~ entre guillemet dans la partie local (avant @). Ensuite, l'adresse email doit être valide, en vérifiant le nom de domaine et le serveur smtp. En recherchant, on trouve que certains serveurs sont des "catch-all", c'est a dire qu'ils acceptent toutes les adresses emails. A partir de là, on va trouver une liste contenant plein de catch all domain (disponible dans le fichier "temporary-email-address-domains"). On peut maintenant envoyer des emails comme : "foo{%if(True)%}yay{%endif%}"@test.com.com. On remarque les espaces ne marche pas meme s'il devait marcher. On trouve des payloads comme {{lipsum[__global__].os.popen("sleep 5").read()}} qui permette d'executer n'importe quelle commande et on trouve aussi qu'il est possible d'utiliser {%if(1==1)%}{%endif%} qui n'utilise pas d'espace et de double crochets. Pour réussir à bypass les underscores et espaces nécessaire a la payload, il faut utiliser des variables. Pour cela, on peut utiliser d'autre arguments et l'injecter dans notre payload, malheusement un filtre nous empeches d'utiliser les mots args et form. On peut se rabattre alors sur les cookies. On trouve au final que la payload suivante passe :  
Cookie:__globals__=t;sleep 5=t;
email="{%if((lipsum|attr(request.cookies|first)).os.popen(request.cookies|last).read())%}{%endif%}"@t.com.com

On fait ensuite un reverse shell car il n'y pas de retour des commandes qu'on effectue (uniquements si elle se sont bien exécuté avec l'astuce de cmd && sleep 3). Ici, le reverse shell était compliqué a effectué facilement (commande basique ne s'exécuté pas correctement). Etant donnée que python s'exécutais sans probleme, il a suffit de télécharger un script reverse shell ("reverse_shell.py") depuis la machine cible correctement paramétré et le lancé. On récupère donc un shell sur la machine. En fouillant, on trouve rapidement le fichier flag.txt qui contient le flag.