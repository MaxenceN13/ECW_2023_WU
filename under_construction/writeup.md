# PROBLEME
Un script app.py qui est exécuté sur un serveur distant.

# SOLUTION
Le script utilise le framework flask et une librairie validate_email.
Après analyse du script, on remarque l'utilisation d'un render_template_string qui utilise un input utilisateur, ce qui le rend vulnérable à une SSTI (Server-Side Template Injection). On souhaiterait donc injecter du code exécuté par flask à l'aide de {{}} ou {%%}. Malheusement, on doit pouvoir passer le validateur d'email qui nous empêche l'utilisation de tels caractères. Après recherche, on trouve la possiblité d'utiliser des "quoted email address" qui permet l'utilisation des caractères !#$%&'*+-/=?^_`{|}~ entre guillemet dans la partie local (avant @). Ensuite, l'adresse email doit être valide, en vérifiant le nom de domaine et le serveur smtp. En recherchant, on trouve que certains serveurs sont configuré en tant que "catch-all", c'est à dire qu'ils acceptent toutes les adresses emails. Après recherche, on trouve une liste contenant plein de catch all domain (disponible dans le fichier "temporary-email-address-domains"). On peut maintenant envoyer des emails comme : "foo{%if(True)%}yay{%endif%}"@test.com.com. On remarque les espaces ne passe pas même s'il aurait dû être valide. On trouve des payloads comme {{lipsum[__global__].os.popen("sleep 5").read()}} très court (car on doit aussi ne pas dépasser la limite des 100 caractères) et qui permet d'exécuter n'importe quelle commande. On trouve aussi qu'il est possible d'utiliser {%if(1==1)%}{%endif%} qui n'utilise pas d'espace et de double crochets (car bloqué par une blacklist). Pour réussir à bypass les underscores et espaces nécessaire à la payload, il faut utiliser des variables. Pour cela, on peut utiliser d'autres arguments et l'injecter dans notre payload, malheusement les mots "args" et "form" font partis de la blacklist. On peut se rabattre alors sur les cookies. On trouve au final que la payload suivante fonctionne :  
Cookie:__globals__=t;sleep 5=t;
email="{%if((lipsum|attr(request.cookies|first)).os.popen(request.cookies|last).read())%}{%endif%}"@bb2.rum

On fait ensuite un reverse shell car il n'y pas de retour des commandes qu'on effectue (uniquements si elles se sont bien exécutés avec l'astuce "cmd && sleep 3"). Ici, les reverse shell en une commande ne voulait pas se fonctionné. Alors, il a suffit de télécharger un script reverse shell en python ("reverse_shell.py") correctement paramétré depuis la machine cible et de le lancer. On récupère enfin un shell sur la machine. En fouillant, on trouve rapidement le fichier flag.txt qui contient le flag.